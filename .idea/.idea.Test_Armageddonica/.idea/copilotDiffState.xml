<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Assets/_Project/Scripts/Architecture/Layout/LinearLayoutStrategy.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Assets/_Project/Scripts/Architecture/Layout/LinearLayoutStrategy.cs" />
              <option name="originalContent" value="using System.Collections.Generic;&#10;using _Project.Scripts.Architecture.Cards.Runtime;&#10;using _Project.Scripts.Architecture.Core.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace _Project.Scripts.Architecture.Layout&#10;{&#10;    /// &lt;summary&gt; Implements a linear layout strategy for arranging objects in a horizontal line. &lt;/summary&gt;&#10;    public class LinearLayoutStrategy : ILayoutStrategy&#10;    {&#10;        private Dictionary&lt;CardUI, Vector3&gt; _positions;&#10;&#10;        /// &lt;summary&gt; Calculates the target positions for a collection of transforms based on the linear layout strategy. &lt;/summary&gt;&#10;        public Dictionary&lt;Transform, Vector3&gt; CalculateLayout(ILayoutData data, LayoutSettings settings)&#10;        {&#10;            if (data == null || data.Transforms == null || data.Transforms.Count == 0)&#10;                return new Dictionary&lt;Transform, Vector3&gt;();&#10;&#10;            // Сбрасываем SiblingIndex в нормальный порядок&#10;            ResetSiblingIndices(data.Transforms);&#10;&#10;            return CalculateBasePositions(data.Transforms, settings);&#10;        }&#10;&#10;        /// &lt;summary&gt; Calculates the target positions for a collection of transforms when one is hovered over. &lt;/summary&gt;&#10;        public Dictionary&lt;Transform, Vector3&gt; CalculateHoverLayout(ILayoutData data, LayoutSettings settings,&#10;            int hoveredIndex)&#10;        {&#10;            if (data == null || data.Transforms == null || data.Transforms.Count == 0)&#10;                return new Dictionary&lt;Transform, Vector3&gt;();&#10;&#10;            var basePositions = CalculateBasePositions(data.Transforms, settings);&#10;            var transformsCount = data.Transforms.Count;&#10;            var hoveredTransform = data.Transforms[hoveredIndex];&#10;&#10;            if (hoveredTransform == null)&#10;                return basePositions;&#10;&#10;            // Поднимаем наведенную карту вверх&#10;            var hoveredPosition = basePositions[hoveredTransform] + new Vector3(0, settings.HoverHeightOffset, 0);&#10;            basePositions[hoveredTransform] = hoveredPosition;&#10;            &#10;            var hoveredX = hoveredPosition.x;&#10;            var hoveredLeftEdge = hoveredX - settings.ObjectWidth / 2;&#10;            var hoveredRightEdge = hoveredX + settings.ObjectWidth / 2;&#10;&#10;            // Определяем максимальное количество затрагиваемых карт&#10;            var maxInfluencedCards = transformsCount / 2;&#10;&#10;            // Обрабатываем карты слева от наведенной&#10;            if (hoveredIndex &gt; 0)&#10;            {&#10;                var firstLeftTransform = data.Transforms[hoveredIndex - 1];&#10;                var firstLeftCurrentPos = basePositions[firstLeftTransform];&#10;                &#10;                // Рассчитываем где должна быть первая левая карта&#10;                var targetRightEdge = hoveredLeftEdge - settings.HoverOffset;&#10;                var targetFirstLeftX = targetRightEdge - settings.ObjectWidth / 2;&#10;                &#10;                // Вычисляем общий сдвиг для всех левых карт&#10;                var leftShift = targetFirstLeftX - firstLeftCurrentPos.x;&#10;                &#10;                // Применяем сдвиг только если нужно сдвигать влево&#10;                if (leftShift &lt; 0)&#10;                {&#10;                    var leftBound = Mathf.Max(0, hoveredIndex - maxInfluencedCards);&#10;                    for (var i = hoveredIndex - 1; i &gt;= leftBound; i--)&#10;                    {&#10;                        var transform = data.Transforms[i];&#10;                        var currentPos = basePositions[transform];&#10;                        var newPos = new Vector3(currentPos.x + leftShift, currentPos.y, currentPos.z);&#10;                        basePositions[transform] = newPos;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Обрабатываем карты справа от наведенной&#10;            if (hoveredIndex &lt; transformsCount - 1)&#10;            {&#10;                var firstRightTransform = data.Transforms[hoveredIndex + 1];&#10;                var firstRightCurrentPos = basePositions[firstRightTransform];&#10;                &#10;                // Рассчитываем где должна быть первая правая карта&#10;                var targetLeftEdge = hoveredRightEdge + settings.HoverOffset;&#10;                var targetFirstRightX = targetLeftEdge + settings.ObjectWidth / 2;&#10;                &#10;                // Вычисляем общий сдвиг для всех правых карт&#10;                var rightShift = targetFirstRightX - firstRightCurrentPos.x;&#10;                &#10;                // Применяем сдвиг только если нужно сдвигать вправо&#10;                if (rightShift &gt; 0)&#10;                {&#10;                    var rightBound = Mathf.Min(transformsCount - 1, hoveredIndex + maxInfluencedCards);&#10;                    for (var i = hoveredIndex + 1; i &lt;= rightBound; i++)&#10;                    {&#10;                        var transform = data.Transforms[i];&#10;                        var currentPos = basePositions[transform];&#10;                        var newPos = new Vector3(currentPos.x + rightShift, currentPos.y, currentPos.z);&#10;                        basePositions[transform] = newPos;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Применяем Z-ordering через SiblingIndex для правильной отрисовки&#10;            ApplyZOrdering(data.Transforms, hoveredIndex, maxInfluencedCards);&#10;&#10;            return basePositions;&#10;        }&#10;&#10;        /// &lt;summary&gt; Calculates the base positions for a collection of transforms in a linear layout. &lt;/summary&gt;&#10;        private Dictionary&lt;Transform, Vector3&gt; CalculateBasePositions(IReadOnlyList&lt;Transform&gt; transforms,&#10;            LayoutSettings settings)&#10;        {&#10;            var positions = new Dictionary&lt;Transform, Vector3&gt;();&#10;&#10;            var transformsCount = transforms.Count;&#10;            var adjustedSpacing = CalculateAdjustedSpacing(settings, transformsCount);&#10;            var totalWidth = transformsCount * settings.ObjectWidth + (transformsCount - 1) * adjustedSpacing;&#10;            var startX = -totalWidth / 2 + settings.ObjectWidth / 2;&#10;&#10;            for (var i = 0; i &lt; transformsCount; i++)&#10;            {&#10;                var targetX = startX + i * (settings.ObjectWidth + adjustedSpacing);&#10;                var targetPosition = new Vector3(targetX, 0, 0);&#10;                positions[transforms[i]] = targetPosition;&#10;            }&#10;&#10;            return positions;&#10;        }&#10;&#10;        /// &lt;summary&gt; Calculates the adjusted spacing between objects to ensure they fit within the maximum width. &lt;/summary&gt;&#10;        private float CalculateAdjustedSpacing(LayoutSettings settings, int transformsCount)&#10;        {&#10;            var totalWidth = transformsCount * settings.ObjectWidth + (transformsCount - 1) * settings.Spacing;&#10;            var adjustedSpacing = settings.Spacing;&#10;            if (totalWidth &gt; settings.MaxWidth)&#10;            {&#10;                var overlapWidth = totalWidth - settings.MaxWidth;&#10;                var spacingReductionPerCard = overlapWidth / (transformsCount - 1);&#10;                adjustedSpacing = Mathf.Max(settings.Spacing - spacingReductionPerCard, settings.MinSpacing);&#10;            }&#10;&#10;            return adjustedSpacing;&#10;        }&#10;&#10;        /// &lt;summary&gt; Applies Z-ordering through SiblingIndex to ensure closer cards render on top. &lt;/summary&gt;&#10;        private void ApplyZOrdering(IReadOnlyList&lt;Transform&gt; transforms, int hoveredIndex, int maxInfluencedCards)&#10;        {&#10;            var transformsCount = transforms.Count;&#10;            var leftBound = Mathf.Max(0, hoveredIndex - maxInfluencedCards);&#10;            var rightBound = Mathf.Min(transformsCount - 1, hoveredIndex + maxInfluencedCards);&#10;            &#10;            // Устанавливаем базовый SiblingIndex для всех карт в зоне влияния&#10;            var baseSiblingIndex = 0;&#10;            &#10;            // Для каждой карты в зоне влияния рассчитываем SiblingIndex&#10;            for (var i = leftBound; i &lt;= rightBound; i++)&#10;            {&#10;                var transform = transforms[i];&#10;                var distanceFromHovered = Mathf.Abs(i - hoveredIndex);&#10;                var maxDistance = Mathf.Max(rightBound - hoveredIndex, hoveredIndex - leftBound);&#10;                &#10;                // Ближайшие карты получают больший SiblingIndex (отрисовываются поверх)&#10;                var siblingIndex = baseSiblingIndex + (maxDistance - distanceFromHovered);&#10;                transform.SetSiblingIndex(siblingIndex);&#10;            }&#10;            &#10;            // Наведенная карта всегда самая верхняя&#10;            transforms[hoveredIndex].SetSiblingIndex(baseSiblingIndex + maxInfluencedCards + 1);&#10;        }&#10;&#10;        /// &lt;summary&gt; Resets SiblingIndex to original order for normal layout. &lt;/summary&gt;&#10;        private void ResetSiblingIndices(IReadOnlyList&lt;Transform&gt; transforms)&#10;        {&#10;            for (var i = 0; i &lt; transforms.Count; i++)&#10;            {&#10;                transforms[i].SetSiblingIndex(i);&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System.Collections.Generic;&#10;using _Project.Scripts.Architecture.Cards.Runtime;&#10;using _Project.Scripts.Architecture.Core.Interfaces;&#10;using UnityEngine;&#10;&#10;namespace _Project.Scripts.Architecture.Layout&#10;{&#10;    /// &lt;summary&gt; Implements a linear layout strategy for arranging objects in a horizontal line. &lt;/summary&gt;&#10;    public class LinearLayoutStrategy : ILayoutStrategy&#10;    {&#10;        private Dictionary&lt;CardUI, Vector3&gt; _positions;&#10;&#10;        /// &lt;summary&gt; Calculates the target positions for a collection of transforms based on the linear layout strategy. &lt;/summary&gt;&#10;        public Dictionary&lt;Transform, Vector3&gt; CalculateLayout(ILayoutData data, LayoutSettings settings)&#10;        {&#10;            if (data == null || data.Transforms == null || data.Transforms.Count == 0)&#10;                return new Dictionary&lt;Transform, Vector3&gt;();&#10;&#10;            // Сбрасываем SiblingIndex в нормальный порядок&#10;            ResetSiblingIndices(data.Transforms);&#10;&#10;            return CalculateBasePositions(data.Transforms, settings);&#10;        }&#10;&#10;        /// &lt;summary&gt; Calculates the target positions for a collection of transforms when one is hovered over. &lt;/summary&gt;&#10;        public Dictionary&lt;Transform, Vector3&gt; CalculateHoverLayout(ILayoutData data, LayoutSettings settings,&#10;            int hoveredIndex)&#10;        {&#10;            if (data == null || data.Transforms == null || data.Transforms.Count == 0)&#10;                return new Dictionary&lt;Transform, Vector3&gt;();&#10;&#10;            var basePositions = CalculateBasePositions(data.Transforms, settings);&#10;            var transformsCount = data.Transforms.Count;&#10;            var hoveredTransform = data.Transforms[hoveredIndex];&#10;&#10;            if (hoveredTransform == null)&#10;                return basePositions;&#10;&#10;            // Поднимаем наведенную карту вверх&#10;            var hoveredPosition = basePositions[hoveredTransform] + new Vector3(0, settings.HoverHeightOffset, 0);&#10;            basePositions[hoveredTransform] = hoveredPosition;&#10;            &#10;            var hoveredX = hoveredPosition.x;&#10;            var hoveredLeftEdge = hoveredX - settings.ObjectWidth / 2;&#10;            var hoveredRightEdge = hoveredX + settings.ObjectWidth / 2;&#10;&#10;            // Определяем максимальное количество затрагиваемых карт&#10;            var maxInfluencedCards = transformsCount / 2;&#10;&#10;            // Обрабатываем карты слева от наведенной&#10;            if (hoveredIndex &gt; 0)&#10;            {&#10;                var firstLeftTransform = data.Transforms[hoveredIndex - 1];&#10;                var firstLeftCurrentPos = basePositions[firstLeftTransform];&#10;                &#10;                // Рассчитываем где должна быть первая левая карта&#10;                var targetRightEdge = hoveredLeftEdge - settings.HoverOffset;&#10;                var targetFirstLeftX = targetRightEdge - settings.ObjectWidth / 2;&#10;                &#10;                // Вычисляем общий сдвиг для всех левых карт&#10;                var leftShift = targetFirstLeftX - firstLeftCurrentPos.x;&#10;                &#10;                // Применяем сдвиг только если нужно сдвигать влево&#10;                if (leftShift &lt; 0)&#10;                {&#10;                    var leftBound = Mathf.Max(0, hoveredIndex - maxInfluencedCards);&#10;                    for (var i = hoveredIndex - 1; i &gt;= leftBound; i--)&#10;                    {&#10;                        var transform = data.Transforms[i];&#10;                        var currentPos = basePositions[transform];&#10;                        var newPos = new Vector3(currentPos.x + leftShift, currentPos.y, currentPos.z);&#10;                        basePositions[transform] = newPos;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Обрабатываем карты справа от наведенной&#10;            if (hoveredIndex &lt; transformsCount - 1)&#10;            {&#10;                var firstRightTransform = data.Transforms[hoveredIndex + 1];&#10;                var firstRightCurrentPos = basePositions[firstRightTransform];&#10;                &#10;                // Рассчитываем где должна быть первая правая карта&#10;                var targetLeftEdge = hoveredRightEdge + settings.HoverOffset;&#10;                var targetFirstRightX = targetLeftEdge + settings.ObjectWidth / 2;&#10;                &#10;                // Вычисляем общий сдвиг для всех правых карт&#10;                var rightShift = targetFirstRightX - firstRightCurrentPos.x;&#10;                &#10;                // Применяем сдвиг только если нужно сдвигать вправо&#10;                if (rightShift &gt; 0)&#10;                {&#10;                    var rightBound = Mathf.Min(transformsCount - 1, hoveredIndex + maxInfluencedCards);&#10;                    for (var i = hoveredIndex + 1; i &lt;= rightBound; i++)&#10;                    {&#10;                        var transform = data.Transforms[i];&#10;                        var currentPos = basePositions[transform];&#10;                        var newPos = new Vector3(currentPos.x + rightShift, currentPos.y, currentPos.z);&#10;                        basePositions[transform] = newPos;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Применяем Z-ordering через SiblingIndex для правильной отрисовки&#10;            ApplyZOrdering(data.Transforms, hoveredIndex, maxInfluencedCards);&#10;&#10;            return basePositions;&#10;        }&#10;&#10;        /// &lt;summary&gt; Calculates the base positions for a collection of transforms in a linear layout. &lt;/summary&gt;&#10;        private Dictionary&lt;Transform, Vector3&gt; CalculateBasePositions(IReadOnlyList&lt;Transform&gt; transforms,&#10;            LayoutSettings settings)&#10;        {&#10;            var positions = new Dictionary&lt;Transform, Vector3&gt;();&#10;&#10;            var transformsCount = transforms.Count;&#10;            var adjustedSpacing = CalculateAdjustedSpacing(settings, transformsCount);&#10;            var totalWidth = transformsCount * settings.ObjectWidth + (transformsCount - 1) * adjustedSpacing;&#10;            var startX = -totalWidth / 2 + settings.ObjectWidth / 2;&#10;&#10;            for (var i = 0; i &lt; transformsCount; i++)&#10;            {&#10;                var targetX = startX + i * (settings.ObjectWidth + adjustedSpacing);&#10;                var targetPosition = new Vector3(targetX, 0, 0);&#10;                positions[transforms[i]] = targetPosition;&#10;            }&#10;&#10;            return positions;&#10;        }&#10;&#10;        /// &lt;summary&gt; Calculates the adjusted spacing between objects to ensure they fit within the maximum width. &lt;/summary&gt;&#10;        private float CalculateAdjustedSpacing(LayoutSettings settings, int transformsCount)&#10;        {&#10;            var totalWidth = transformsCount * settings.ObjectWidth + (transformsCount - 1) * settings.Spacing;&#10;            var adjustedSpacing = settings.Spacing;&#10;            if (totalWidth &gt; settings.MaxWidth)&#10;            {&#10;                var overlapWidth = totalWidth - settings.MaxWidth;&#10;                var spacingReductionPerCard = overlapWidth / (transformsCount - 1);&#10;                adjustedSpacing = Mathf.Max(settings.Spacing - spacingReductionPerCard, settings.MinSpacing);&#10;            }&#10;&#10;            return adjustedSpacing;&#10;        }&#10;&#10;        /// &lt;summary&gt; Applies Z-ordering through SiblingIndex to ensure closer cards render on top. &lt;/summary&gt;&#10;        private void ApplyZOrdering(IReadOnlyList&lt;Transform&gt; transforms, int hoveredIndex, int maxInfluencedCards)&#10;        {&#10;            var transformsCount = transforms.Count;&#10;            var leftBound = Mathf.Max(0, hoveredIndex - maxInfluencedCards);&#10;            var rightBound = Mathf.Min(transformsCount - 1, hoveredIndex + maxInfluencedCards);&#10;            &#10;            // Устанавливаем базовый SiblingIndex для всех карт в зоне влияния&#10;            var baseSiblingIndex = 0;&#10;            &#10;            // Для каждой карты в зоне влияния рассчитываем SiblingIndex&#10;            for (var i = leftBound; i &lt;= rightBound; i++)&#10;            {&#10;                var transform = transforms[i];&#10;                var distanceFromHovered = Mathf.Abs(i - hoveredIndex);&#10;                var maxDistance = Mathf.Max(rightBound - hoveredIndex, hoveredIndex - leftBound);&#10;                &#10;                // Ближайшие карты получают больший SiblingIndex (отрисовываются поверх)&#10;                var siblingIndex = baseSiblingIndex + (maxDistance - distanceFromHovered);&#10;                transform.SetSiblingIndex(siblingIndex);&#10;            }&#10;            &#10;            // Наведенная карта всегда самая верхняя&#10;            transforms[hoveredIndex].SetSiblingIndex(baseSiblingIndex + maxInfluencedCards + 1);&#10;        }&#10;&#10;        /// &lt;summary&gt; Resets SiblingIndex to original order for normal layout. &lt;/summary&gt;&#10;        private void ResetSiblingIndices(IReadOnlyList&lt;Transform&gt; transforms)&#10;        {&#10;            for (var i = 0; i &lt; transforms.Count; i++)&#10;            {&#10;                transforms[i].SetSiblingIndex(i);&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>